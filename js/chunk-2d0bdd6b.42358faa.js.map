{"version":3,"sources":["webpack:///./src/docs/api/-_core_Interaction.ts.html"],"names":["module","exports"],"mappings":"mGAAAA,EAAAC,QAAA","file":"js/chunk-2d0bdd6b.42358faa.js","sourcesContent":["module.exports = \"<nav class=\\\"jsdoc-nav\\\">\\n<li class=\\\"nav-link nav-home-link\\\"><a href=\\\"/docs/api/index.html\\\">Home</a></li><li class=\\\"nav-heading\\\">Classes</li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-class\\\">C</span><span class=\\\"nav-item-name\\\"><a href=\\\"DropEvent.html\\\">DropEvent</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"DropEvent.html#reject\\\">reject</a></span></li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-class\\\">C</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html\\\">Interactable</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#context\\\">context</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#deltaSource\\\">deltaSource</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#draggable\\\">draggable</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#dropCheck\\\">dropCheck</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#dropzone\\\">dropzone</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#fire\\\">fire</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#gesturable\\\">gesturable</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#getRect\\\">getRect</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#off\\\">off</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#on\\\">on</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#origin\\\">origin</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#rectChecker\\\">rectChecker</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#reflow\\\">reflow</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#resizable\\\">resizable</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#set\\\">set</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"Interactable.html#unset\\\">unset</a></span></li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-class\\\">C</span><span class=\\\"nav-item-name\\\"><a href=\\\"InteractEvent_InteractEvent.html\\\">InteractEvent</a></span></li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-class\\\">C</span><span class=\\\"nav-item-name\\\"><a href=\\\"module.exports.html\\\">exports</a></span></li><li class=\\\"nav-heading\\\">Modules</li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-module\\\">M</span><span class=\\\"nav-item-name\\\"><a href=\\\"module-interact.html\\\">interact</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"module-interact.html#.maxInteractions\\\">maxInteractions</a></span></li><li class=\\\"nav-heading\\\"><span class=\\\"nav-item-type type-module\\\">M</span><span class=\\\"nav-item-name\\\"><a href=\\\"module-modifiers_snapEdges.html\\\">modifiers/snapEdges</a></span></li><li class=\\\"nav-heading\\\"><a href=\\\"global.html\\\">Globals</a></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-member\\\">M</span><span class=\\\"nav-item-name\\\"><a href=\\\"global.html#interact\\\">interact</a></span></li><li class=\\\"nav-item\\\"><span class=\\\"nav-item-type type-function\\\">F</span><span class=\\\"nav-item-name\\\"><a href=\\\"global.html#preventDefault\\\">preventDefault</a></span></li>\\n</nav>\\n\\n\\n<h1 class=\\\"page-title\\\">/core/Interaction.ts</h1>\\n\\n\\n\\n\\n\\n\\n    \\n    <section>\\n        <article>\\n            <pre class=\\\"prettyprint source linenums\\\"><code>import * as utils from '@interactjs/utils'\\nimport Interactable from './Interactable'\\nimport InteractEvent, { EventPhase } from './InteractEvent'\\nimport PointerInfo from './PointerInfo'\\nimport { ActionName } from './scope'\\n\\nexport interface ActionProps&lt;T extends ActionName = any> {\\n  name: T\\n  axis?: 'x' | 'y' | 'xy'\\n  edges?: {\\n    [edge in keyof Interact.Rect]?: boolean\\n  }\\n}\\n\\nexport interface StartAction extends ActionProps {\\n  name: ActionName | string\\n}\\n\\nexport type InteractionProxy = Pick&lt;Interaction,\\n  'pointerIsDown' |\\n  'pointerWasMoved' |\\n  'start' |\\n  'move' |\\n  'end' |\\n  'stop' |\\n  'interacting' |\\n  '_proxy'\\n>\\n\\nexport class Interaction&lt;T extends ActionName = any> {\\n  // current interactable being interacted with\\n  interactable: Interactable = null\\n\\n  // the target element of the interactable\\n  element: Element = null\\n  rect: Interact.Rect &amp; Interact.Size\\n  edges: {\\n    [P in keyof Interact.Rect]?: boolean\\n  }\\n\\n  _signals: utils.Signals\\n\\n  // action that's ready to be fired on next move event\\n  prepared: ActionProps&lt;T> = {\\n    name : null,\\n    axis : null,\\n    edges: null,\\n  }\\n\\n  pointerType: string\\n\\n  // keep track of added pointers\\n  pointers: PointerInfo[] = []\\n\\n  // pointerdown/mousedown/touchstart event\\n  downEvent: Interact.PointerEventType = null\\n\\n  downPointer: Interact.PointerType = {} as Interact.PointerType\\n\\n  _latestPointer: {\\n    pointer: Interact.EventTarget\\n    event: Interact.PointerEventType\\n    eventTarget: Node,\\n  } = {\\n    pointer: null,\\n    event: null,\\n    eventTarget: null,\\n  }\\n\\n  // previous action event\\n  prevEvent: InteractEvent&lt;T> = null\\n\\n  pointerIsDown = false\\n  pointerWasMoved = false\\n  _interacting = false\\n  _ending = false\\n  _proxy: InteractionProxy = null\\n\\n  simulation = null\\n\\n  get pointerMoveTolerance () {\\n    return 1\\n  }\\n\\n  /**\\n   * @alias Interaction.prototype.move\\n   */\\n  doMove = utils.warnOnce(\\n    function (this: Interaction, signalArg: any) {\\n      this.move(signalArg)\\n    },\\n    'The interaction.doMove() method has been renamed to interaction.move()')\\n\\n  coords = {\\n    // Starting InteractEvent pointer coordinates\\n    start: utils.pointer.newCoords(),\\n    // Previous native pointer move event coordinates\\n    prev: utils.pointer.newCoords(),\\n    // current native pointer move event coordinates\\n    cur: utils.pointer.newCoords(),\\n    // Change in coordinates and time of the pointer\\n    delta: utils.pointer.newCoords(),\\n    // pointer velocity\\n    velocity: utils.pointer.newCoords(),\\n  }\\n\\n  /** */\\n  constructor ({ pointerType, signals }: { pointerType?: string, signals: utils.Signals }) {\\n    this._signals = signals\\n    this.pointerType = pointerType\\n\\n    const that = this\\n\\n    this._proxy = {\\n      get pointerIsDown () { return that.pointerIsDown },\\n      get pointerWasMoved () { return that.pointerWasMoved },\\n      start (action, i, e) { return that.start(action, i, e) },\\n      move (arg) { return that.move(arg) },\\n      end (event) { return that.end(event) },\\n      stop () { return that.stop() },\\n      interacting () { return that.interacting() },\\n      get _proxy () { return this },\\n    }\\n\\n    this._signals.fire('new', { interaction: this })\\n  }\\n\\n  pointerDown (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: EventTarget) {\\n    const pointerIndex = this.updatePointer(pointer, event, eventTarget, true)\\n\\n    this._signals.fire('down', {\\n      pointer,\\n      event,\\n      eventTarget,\\n      pointerIndex,\\n      interaction: this,\\n    })\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable({\\n   *     // disable the default drag start by down->move\\n   *     manualStart: true\\n   *   })\\n   *   // start dragging after the user holds the pointer down\\n   *   .on('hold', function (event) {\\n   *     var interaction = event.interaction\\n   *\\n   *     if (!interaction.interacting()) {\\n   *       interaction.start({ name: 'drag' },\\n   *                         event.interactable,\\n   *                         event.currentTarget)\\n   *     }\\n   * })\\n   * ```\\n   *\\n   * Start an action with the given Interactable and Element as tartgets. The\\n   * action must be enabled for the target Interactable and an appropriate\\n   * number of pointers must be held down - 1 for drag/resize, 2 for gesture.\\n   *\\n   * Use it with `interactable.&lt;action>able({ manualStart: false })` to always\\n   * [start actions manually](https://github.com/taye/interact.js/issues/114)\\n   *\\n   * @param {object} action   The action to be performed - drag, resize, etc.\\n   * @param {Interactable} target  The Interactable to target\\n   * @param {Element} element The DOM Element to target\\n   * @return {object} interact\\n   */\\n  start (action: StartAction, interactable: Interactable, element: Element) {\\n    if (this.interacting() ||\\n        !this.pointerIsDown ||\\n        this.pointers.length &lt; (action.name === ActionName.Gesture ? 2 : 1) ||\\n        !interactable.options[action.name].enabled) {\\n      return false\\n    }\\n\\n    utils.copyAction(this.prepared, action)\\n\\n    this.interactable = interactable\\n    this.element      = element\\n    this.rect         = interactable.getRect(element)\\n    this.edges        = this.prepared.edges\\n    this._interacting = this._doPhase({\\n      interaction: this,\\n      event: this.downEvent,\\n      phase: EventPhase.Start,\\n    })\\n\\n    return this._interacting\\n  }\\n\\n  pointerMove (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: EventTarget) {\\n    if (!this.simulation) {\\n      this.updatePointer(pointer, event, eventTarget, false)\\n      utils.pointer.setCoords(this.coords.cur, this.pointers.map((p) => p.pointer), this._now())\\n    }\\n\\n    const duplicateMove = (this.coords.cur.page.x === this.coords.prev.page.x &amp;&amp;\\n                           this.coords.cur.page.y === this.coords.prev.page.y &amp;&amp;\\n                           this.coords.cur.client.x === this.coords.prev.client.x &amp;&amp;\\n                           this.coords.cur.client.y === this.coords.prev.client.y)\\n\\n    let dx\\n    let dy\\n\\n    // register movement greater than pointerMoveTolerance\\n    if (this.pointerIsDown &amp;&amp; !this.pointerWasMoved) {\\n      dx = this.coords.cur.client.x - this.coords.start.client.x\\n      dy = this.coords.cur.client.y - this.coords.start.client.y\\n\\n      this.pointerWasMoved = utils.hypot(dx, dy) > this.pointerMoveTolerance\\n    }\\n\\n    const signalArg = {\\n      pointer,\\n      pointerIndex: this.getPointerIndex(pointer),\\n      event,\\n      eventTarget,\\n      dx,\\n      dy,\\n      duplicate: duplicateMove,\\n      interaction: this,\\n    }\\n\\n    if (!duplicateMove) {\\n      // set pointer coordinate, time changes and velocity\\n      utils.pointer.setCoordDeltas(this.coords.delta, this.coords.prev, this.coords.cur)\\n      utils.pointer.setCoordVelocity(this.coords.velocity, this.coords.delta)\\n    }\\n\\n    this._signals.fire('move', signalArg)\\n\\n    if (!duplicateMove) {\\n      // if interacting, fire an 'action-move' signal etc\\n      if (this.interacting()) {\\n        this.move(signalArg)\\n      }\\n\\n      if (this.pointerWasMoved) {\\n        utils.pointer.copyCoords(this.coords.prev, this.coords.cur)\\n      }\\n    }\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable(true)\\n   *   .on('dragmove', function (event) {\\n   *     if (someCondition) {\\n   *       // change the snap settings\\n   *       event.interactable.draggable({ snap: { targets: [] }})\\n   *       // fire another move event with re-calculated snap\\n   *       event.interaction.move()\\n   *     }\\n   *   })\\n   * ```\\n   *\\n   * Force a move of the current action at the same coordinates. Useful if\\n   * snap/restrict has been changed and you want a movement with the new\\n   * settings.\\n   */\\n  move (signalArg?) {\\n    signalArg = utils.extend({\\n      pointer: this._latestPointer.pointer,\\n      event: this._latestPointer.event,\\n      eventTarget: this._latestPointer.eventTarget,\\n      interaction: this,\\n    }, signalArg || {})\\n\\n    signalArg.phase = EventPhase.Move\\n\\n    this._doPhase(signalArg)\\n  }\\n\\n  // End interact move events and stop auto-scroll unless simulation is running\\n  pointerUp (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: EventTarget, curEventTarget: EventTarget) {\\n    let pointerIndex = this.getPointerIndex(pointer)\\n\\n    if (pointerIndex === -1) {\\n      pointerIndex = this.updatePointer(pointer, event, eventTarget, false)\\n    }\\n\\n    this._signals.fire(/cancel$/i.test(event.type) ? 'cancel' : 'up', {\\n      pointer,\\n      pointerIndex,\\n      event,\\n      eventTarget,\\n      curEventTarget,\\n      interaction: this,\\n    })\\n\\n    if (!this.simulation) {\\n      this.end(event)\\n    }\\n\\n    this.pointerIsDown = false\\n    this.removePointer(pointer, event)\\n  }\\n\\n  documentBlur (event) {\\n    this.end(event)\\n    this._signals.fire('blur', { event, interaction: this })\\n  }\\n\\n  /**\\n   * ```js\\n   * interact(target)\\n   *   .draggable(true)\\n   *   .on('move', function (event) {\\n   *     if (event.pageX > 1000) {\\n   *       // end the current action\\n   *       event.interaction.end()\\n   *       // stop all further listeners from being called\\n   *       event.stopImmediatePropagation()\\n   *     }\\n   *   })\\n   * ```\\n   *\\n   * @param {PointerEvent} [event]\\n   */\\n  end (event?: Interact.PointerEventType) {\\n    this._ending = true\\n    event = event || this._latestPointer.event\\n    let endPhaseResult\\n\\n    if (this.interacting()) {\\n      endPhaseResult = this._doPhase({\\n        event,\\n        interaction: this,\\n        phase: EventPhase.End,\\n      })\\n    }\\n\\n    this._ending = false\\n\\n    if (endPhaseResult === true) {\\n      this.stop()\\n    }\\n  }\\n\\n  currentAction () {\\n    return this._interacting ? this.prepared.name : null\\n  }\\n\\n  interacting () {\\n    return this._interacting\\n  }\\n\\n  /** */\\n  stop () {\\n    this._signals.fire('stop', { interaction: this })\\n\\n    this.interactable = this.element = null\\n\\n    this._interacting = false\\n    this.prepared.name = this.prevEvent = null\\n  }\\n\\n  getPointerIndex (pointer) {\\n    const pointerId = utils.pointer.getPointerId(pointer)\\n\\n    // mouse and pen interactions may have only one pointer\\n    return (this.pointerType === 'mouse' || this.pointerType === 'pen')\\n      ? this.pointers.length - 1\\n      : utils.arr.findIndex(this.pointers, (curPointer) => curPointer.id === pointerId)\\n  }\\n\\n  getPointerInfo (pointer) {\\n    return this.pointers[this.getPointerIndex(pointer)]\\n  }\\n\\n  updatePointer (pointer: Interact.PointerType, event: Interact.PointerEventType, eventTarget: EventTarget, down?: boolean) {\\n    const id = utils.pointer.getPointerId(pointer)\\n    let pointerIndex = this.getPointerIndex(pointer)\\n    let pointerInfo = this.pointers[pointerIndex]\\n\\n    down = down === false\\n      ? false\\n      : down || /(down|start)$/i.test(event.type)\\n\\n    if (!pointerInfo) {\\n      pointerInfo = new PointerInfo(\\n        id,\\n        pointer,\\n        event,\\n        null,\\n        null,\\n      )\\n\\n      pointerIndex = this.pointers.length\\n      this.pointers.push(pointerInfo)\\n    }\\n    else {\\n      pointerInfo.pointer = pointer\\n    }\\n\\n    if (down) {\\n      this.pointerIsDown = true\\n\\n      if (!this.interacting()) {\\n        utils.pointer.setCoords(this.coords.start, this.pointers.map((p) => p.pointer), this._now())\\n\\n        utils.pointer.copyCoords(this.coords.cur, this.coords.start)\\n        utils.pointer.copyCoords(this.coords.prev, this.coords.start)\\n        utils.pointer.pointerExtend(this.downPointer, pointer)\\n\\n        this.downEvent = event\\n        pointerInfo.downTime = this.coords.cur.timeStamp\\n        pointerInfo.downTarget = eventTarget\\n\\n        this.pointerWasMoved = false\\n      }\\n    }\\n\\n    this._updateLatestPointer(pointer, event, eventTarget)\\n\\n    this._signals.fire('update-pointer', {\\n      pointer,\\n      event,\\n      eventTarget,\\n      down,\\n      pointerInfo,\\n      pointerIndex,\\n      interaction: this,\\n    })\\n\\n    return pointerIndex\\n  }\\n\\n  removePointer (pointer, event) {\\n    const pointerIndex = this.getPointerIndex(pointer)\\n\\n    if (pointerIndex === -1) { return }\\n\\n    const pointerInfo = this.pointers[pointerIndex]\\n\\n    this._signals.fire('remove-pointer', {\\n      pointer,\\n      event,\\n      pointerIndex,\\n      pointerInfo,\\n      interaction: this,\\n    })\\n\\n    this.pointers.splice(pointerIndex, 1)\\n  }\\n\\n  _updateLatestPointer (pointer, event, eventTarget) {\\n    this._latestPointer.pointer = pointer\\n    this._latestPointer.event = event\\n    this._latestPointer.eventTarget = eventTarget\\n  }\\n\\n  _createPreparedEvent (event: Interact.PointerEventType, phase: EventPhase, preEnd: boolean, type: string) {\\n    const actionName = this.prepared.name\\n\\n    return new InteractEvent(this, event, actionName, phase, this.element, null, preEnd, type)\\n  }\\n\\n  _fireEvent (iEvent) {\\n    this.interactable.fire(iEvent)\\n\\n    if (!this.prevEvent || iEvent.timeStamp >= this.prevEvent.timeStamp) {\\n      this.prevEvent = iEvent\\n    }\\n  }\\n\\n  _doPhase (signalArg: Partial&lt;Interact.SignalArg>) {\\n    const { event, phase, preEnd, type } = signalArg\\n    const beforeResult = this._signals.fire(`before-action-${phase}`, signalArg)\\n\\n    if (beforeResult === false) {\\n      return false\\n    }\\n\\n    const iEvent = signalArg.iEvent = this._createPreparedEvent(event, phase, preEnd, type)\\n    const { rect } = this\\n\\n    if (rect) {\\n      // update the rect modifications\\n      const edges = this.edges || this.prepared.edges || { left: true, right: true, top: true, bottom: true }\\n\\n      if (edges.top)    { rect.top    += iEvent.delta.y }\\n      if (edges.bottom) { rect.bottom += iEvent.delta.y }\\n      if (edges.left)   { rect.left   += iEvent.delta.x }\\n      if (edges.right)  { rect.right  += iEvent.delta.x }\\n\\n      rect.width = rect.right - rect.left\\n      rect.height = rect.bottom - rect.top\\n    }\\n\\n    this._signals.fire(`action-${phase}`, signalArg)\\n\\n    this._fireEvent(iEvent)\\n\\n    this._signals.fire(`after-action-${phase}`, signalArg)\\n\\n    return true\\n  }\\n\\n  _now () { return Date.now() }\\n}\\n\\nexport default Interaction\\nexport { PointerInfo }\\n</code></pre>\\n        </article>\\n    </section>\\n\\n\\n\\n\\n\";"],"sourceRoot":""}