(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b3109"],{"277e":function(e,n){e.exports='<nav class="jsdoc-nav">\n<li class="nav-link nav-home-link"><a href="/docs/api/index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="DropEvent.html">DropEvent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DropEvent.html#reject">reject</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Interactable.html">Interactable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#context">context</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#deltaSource">deltaSource</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#draggable">draggable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropCheck">dropCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropzone">dropzone</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#fire">fire</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#gesturable">gesturable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#getRect">getRect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#off">off</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#on">on</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#origin">origin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#rectChecker">rectChecker</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#reflow">reflow</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#resizable">resizable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#set">set</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#unset">unset</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="InteractEvent_InteractEvent.html">InteractEvent</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module.exports.html">exports</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-interact.html">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-interact.html#.maxInteractions">maxInteractions</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-modifiers_snapEdges.html">modifiers/snapEdges</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#interact">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#preventDefault">preventDefault</a></span></li>\n</nav>\n\n\n<h1 class="page-title">/actions/resize.ts</h1>\n\n\n\n\n\n\n    \n    <section>\n        <article>\n            <pre class="prettyprint source linenums"><code>import { ActionProps, Interaction } from \'@interactjs/core/Interaction\'\nimport { ActionName, Scope } from \'@interactjs/core/scope\'\nimport * as utils from \'@interactjs/utils\'\n\nexport type EdgeName = \'top\' | \'left\' | \'bottom\' | \'right\'\n\nexport type ResizableMethod = Interact.ActionMethod&lt;Interact.ResizableOptions>\n\ndeclare module \'@interactjs/core/Interactable\' {\n  interface Interactable {\n    resizable: ResizableMethod\n  }\n}\n\ndeclare module \'@interactjs/core/Interaction\' {\n  interface Interaction {\n    resizeAxes: \'x\' | \'y\' | \'xy\'\n    resizeRects: {\n      start: Required&lt;Interact.Rect>\n      current: Interact.Rect\n      inverted: Required&lt;Interact.Rect>\n      previous: Required&lt;Interact.Rect>\n      delta: Required&lt;Interact.Rect>\n    }\n    resizeStartAspectRatio: number\n  }\n\n  interface ActionProps {\n    _linkedEdges?: { [key: string]: boolean }\n  }\n}\n\ndeclare module \'@interactjs/core/defaultOptions\' {\n  interface ActionDefaults {\n    resize: Interact.ResizableOptions\n  }\n}\n\ndeclare module \'@interactjs/core/scope\' {\n  interface Actions {\n    [ActionName.Resize]?: typeof resize\n  }\n\n  // eslint-disable-next-line no-shadow\n  enum ActionName {\n    Resize = \'resize\'\n  }\n}\n\n(ActionName as any).Resize = \'resize\'\n\nexport interface ResizeEvent extends Interact.InteractEvent&lt;ActionName.Resize> {\n  deltaRect?: Required&lt;Interact.Rect>\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    browser,\n    /** @lends Interactable */\n    Interactable, // tslint:disable-line no-shadowed-variable\n    interactions,\n    defaults,\n  } = scope\n\n  // Less Precision with touch input\n\n  interactions.signals.on(\'new\', (interaction) => {\n    interaction.resizeAxes = \'xy\'\n  })\n\n  interactions.signals.on(\'action-start\', start)\n  interactions.signals.on(\'action-move\', move)\n\n  interactions.signals.on(\'action-start\', updateEventAxes)\n  interactions.signals.on(\'action-move\', updateEventAxes)\n\n  resize.cursors = initCursors(browser)\n  resize.defaultMargin = browser.supportsTouch || browser.supportsPointerEvent ? 20 : 10\n\n  /**\n   * ```js\n   * interact(element).resizable({\n   *   onstart: function (event) {},\n   *   onmove : function (event) {},\n   *   onend  : function (event) {},\n   *\n   *   edges: {\n   *     top   : true,       // Use pointer coords to check for resize.\n   *     left  : false,      // Disable resizing from left edge.\n   *     bottom: \'.resize-s\',// Resize if pointer target matches selector\n   *     right : handleEl    // Resize if pointer target is the given Element\n   *   },\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height are adjusted at a 1:1 ratio.\n   *     square: false,\n   *\n   *     // Width and height can be adjusted independently. When `true`, width and\n   *     // height maintain the aspect ratio they had when resizing started.\n   *     preserveAspectRatio: false,\n   *\n   *   // a value of \'none\' will limit the resize rect to a minimum of 0x0\n   *   // \'negate\' will allow the rect to have negative width/height\n   *   // \'reposition\' will keep the width/height positive by swapping\n   *   // the top and bottom edges and/or swapping the left and right edges\n   *   invert: \'none\' || \'negate\' || \'reposition\'\n   *\n   *   // limit multiple resizes.\n   *   // See the explanation in the {@link Interactable.draggable} example\n   *   max: Infinity,\n   *   maxPerElement: 1,\n   * })\n   *\n   * var isResizeable = interact(element).resizable()\n   * ```\n   *\n   * Gets or sets whether resize actions can be performed on the target\n   *\n   * @param {boolean | object} [options] true/false or An object with event\n   * listeners to be fired on resize events (object makes the Interactable\n   * resizable)\n   * @return {boolean | Interactable} A boolean indicating if this can be the\n   * target of resize elements, or this Interactable\n   */\n  Interactable.prototype.resizable = function (this: Interact.Interactable, options: Interact.ResizableOptions | boolean) {\n    return resizable(this, options, scope)\n  } as ResizableMethod\n\n  actions[ActionName.Resize] = resize\n  actions.names.push(ActionName.Resize)\n  utils.arr.merge(actions.eventTypes, [\n    \'resizestart\',\n    \'resizemove\',\n    \'resizeinertiastart\',\n    \'resizeresume\',\n    \'resizeend\',\n  ])\n  actions.methodDict.resize = \'resizable\'\n\n  defaults.actions.resize = resize.defaults\n}\n\nconst resize = {\n  id: \'actions/resize\',\n  install,\n  defaults: {\n    square: false,\n    preserveAspectRatio: false,\n    axis: \'xy\',\n\n    // use default margin\n    margin: NaN,\n\n    // object with props left, right, top, bottom which are\n    // true/false values to resize when the pointer is over that edge,\n    // CSS selectors to match the handles for each direction\n    // or the Elements for each handle\n    edges: null,\n\n    // a value of \'none\' will limit the resize rect to a minimum of 0x0\n    // \'negate\' will alow the rect to have negative width/height\n    // \'reposition\' will keep the width/height positive by swapping\n    // the top and bottom edges and/or swapping the left and right edges\n    invert: \'none\',\n  } as Interact.ResizableOptions,\n\n  checker (\n    _pointer: Interact.PointerType,\n    _event: Interact.PointerEventType,\n    interactable: Interact.Interactable,\n    element: Element,\n    interaction: Interaction,\n    rect: Interact.Rect\n  ) {\n    if (!rect) { return null }\n\n    const page = utils.extend({}, interaction.coords.cur.page)\n    const options = interactable.options\n\n    if (options.resize.enabled) {\n      const resizeOptions = options.resize\n      const resizeEdges: { [edge: string]: boolean } = { left: false, right: false, top: false, bottom: false }\n\n      // if using resize.edges\n      if (utils.is.object(resizeOptions.edges)) {\n        for (const edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge,\n            resizeOptions.edges[edge],\n            page,\n            interaction._latestPointer.eventTarget,\n            element,\n            rect,\n            resizeOptions.margin || this.defaultMargin)\n        }\n\n        resizeEdges.left = resizeEdges.left &amp;&amp; !resizeEdges.right\n        resizeEdges.top  = resizeEdges.top  &amp;&amp; !resizeEdges.bottom\n\n        if (resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom) {\n          return {\n            name: \'resize\',\n            edges: resizeEdges,\n          }\n        }\n      }\n      else {\n        const right  = options.resize.axis !== \'y\' &amp;&amp; page.x > (rect.right  - this.defaultMargin)\n        const bottom = options.resize.axis !== \'x\' &amp;&amp; page.y > (rect.bottom - this.defaultMargin)\n\n        if (right || bottom) {\n          return {\n            name: \'resize\',\n            axes: (right ? \'x\' : \'\') + (bottom ? \'y\' : \'\'),\n          }\n        }\n      }\n    }\n\n    return null\n  },\n\n  cursors: null as unknown as ReturnType&lt;typeof initCursors>,\n\n  getCursor (action: ActionProps) {\n    const cursors = resize.cursors as { [key: string]: string }\n    if (action.axis) {\n      return cursors[action.name + action.axis]\n    }\n    else if (action.edges) {\n      let cursorKey = \'\'\n      const edgeNames = [\'top\', \'bottom\', \'left\', \'right\']\n\n      for (let i = 0; i &lt; 4; i++) {\n        if (action.edges[edgeNames[i]]) {\n          cursorKey += edgeNames[i]\n        }\n      }\n\n      return cursors[cursorKey]\n    }\n\n    return null\n  },\n\n  defaultMargin: null as unknown as number,\n}\n\nfunction resizable (interactable: Interact.Interactable, options: Interact.OrBoolean&lt;Interact.ResizableOptions> | boolean, scope: Scope) {\n  if (utils.is.object(options)) {\n    interactable.options.resize.enabled = options.enabled !== false\n    interactable.setPerAction(\'resize\', options)\n    interactable.setOnEvents(\'resize\', options)\n\n    if (utils.is.string(options.axis) &amp;&amp; /^x$|^y$|^xy$/.test(options.axis)) {\n      interactable.options.resize.axis = options.axis\n    }\n    else if (options.axis === null) {\n      interactable.options.resize.axis = scope.defaults.actions.resize.axis\n    }\n\n    if (utils.is.bool(options.preserveAspectRatio)) {\n      interactable.options.resize.preserveAspectRatio = options.preserveAspectRatio\n    }\n    else if (utils.is.bool(options.square)) {\n      interactable.options.resize.square = options.square\n    }\n\n    return interactable\n  }\n  if (utils.is.bool(options)) {\n    interactable.options.resize.enabled = options\n\n    return interactable\n  }\n  return interactable.options.resize\n}\n\nfunction checkResizeEdge (name: string, value: any, page: Interact.Point, element: Node, interactableElement: Element, rect: Interact.Rect, margin: number) {\n  // false, \'\', undefined, null\n  if (!value) { return false }\n\n  // true value, use pointer coords and element rect\n  if (value === true) {\n    // if dimensions are negative, "switch" edges\n    const width  = utils.is.number(rect.width) ? rect.width  : rect.right  - rect.left\n    const height = utils.is.number(rect.height) ? rect.height : rect.bottom - rect.top\n\n    // don\'t use margin greater than half the relevent dimension\n    margin = Math.min(margin, (name === \'left\' || name === \'right\' ? width : height) / 2)\n\n    if (width &lt; 0) {\n      if      (name === \'left\')  { name = \'right\' }\n      else if (name === \'right\') { name = \'left\'  }\n    }\n    if (height &lt; 0) {\n      if      (name === \'top\')    { name = \'bottom\' }\n      else if (name === \'bottom\') { name = \'top\'    }\n    }\n\n    if (name === \'left\') { return page.x &lt; ((width  >= 0 ? rect.left : rect.right) + margin) }\n    if (name === \'top\') { return page.y &lt; ((height >= 0 ? rect.top : rect.bottom) + margin) }\n\n    if (name === \'right\') { return page.x > ((width  >= 0 ? rect.right : rect.left) - margin) }\n    if (name === \'bottom\') { return page.y > ((height >= 0 ? rect.bottom : rect.top) - margin) }\n  }\n\n  // the remaining checks require an element\n  if (!utils.is.element(element)) { return false }\n\n  return utils.is.element(value)\n  // the value is an element to use as a resize handle\n    ? value === element\n    // otherwise check if element matches value as selector\n    : utils.dom.matchesUpTo(element, value, interactableElement)\n}\n\nfunction initCursors (browser: typeof import (\'@interactjs/utils/browser\').default) {\n  return (browser.isIe9 ? {\n    x : \'e-resize\',\n    y : \'s-resize\',\n    xy: \'se-resize\',\n\n    top        : \'n-resize\',\n    left       : \'w-resize\',\n    bottom     : \'s-resize\',\n    right      : \'e-resize\',\n    topleft    : \'se-resize\',\n    bottomright: \'se-resize\',\n    topright   : \'ne-resize\',\n    bottomleft : \'ne-resize\',\n  } : {\n    x : \'ew-resize\',\n    y : \'ns-resize\',\n    xy: \'nwse-resize\',\n\n    top        : \'ns-resize\',\n    left       : \'ew-resize\',\n    bottom     : \'ns-resize\',\n    right      : \'ew-resize\',\n    topleft    : \'nwse-resize\',\n    bottomright: \'nwse-resize\',\n    topright   : \'nesw-resize\',\n    bottomleft : \'nesw-resize\',\n  })\n}\n\nfunction start ({ iEvent, interaction }: Interact.SignalArg) {\n  if (interaction.prepared.name !== \'resize\' || !interaction.prepared.edges) {\n    return\n  }\n\n  const startRect = interaction.rect\n  const resizeOptions = interaction.interactable.options.resize\n\n  /*\n   * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n   * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n   * the bottom edge larger by the same amount. We call these \'linked\' edges. Any linked edges will depend\n   * on the active edges and the edge being interacted with.\n   */\n  if (resizeOptions.square || resizeOptions.preserveAspectRatio) {\n    const linkedEdges = utils.extend({}, interaction.prepared.edges)\n\n    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   &amp;&amp; !linkedEdges.bottom)\n    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    &amp;&amp; !linkedEdges.right)\n    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  &amp;&amp; !linkedEdges.top)\n    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom &amp;&amp; !linkedEdges.left)\n\n    interaction.prepared._linkedEdges = linkedEdges\n  }\n  else {\n    interaction.prepared._linkedEdges = null\n  }\n\n  // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n  if (resizeOptions.preserveAspectRatio) {\n    interaction.resizeStartAspectRatio = startRect.width / startRect.height\n  }\n\n  interaction.resizeRects = {\n    start     : startRect,\n    current   : utils.extend({}, startRect),\n    inverted  : utils.extend({}, startRect),\n    previous  : utils.extend({}, startRect),\n    delta     : {\n      left: 0,\n      right : 0,\n      width : 0,\n      top : 0,\n      bottom: 0,\n      height: 0,\n    },\n  }\n\n  iEvent.rect = interaction.resizeRects.inverted\n  ; (iEvent as ResizeEvent).deltaRect = interaction.resizeRects.delta\n}\n\nfunction move ({ iEvent, interaction }) {\n  if (interaction.prepared.name !== \'resize\' || !interaction.prepared.edges) { return }\n\n  const resizeOptions = interaction.interactable.options.resize\n  const invert = resizeOptions.invert\n  const invertible = invert === \'reposition\' || invert === \'negate\'\n\n  let edges = interaction.prepared.edges\n\n  // eslint-disable-next-line no-shadow\n  const start      = interaction.resizeRects.start\n  const current    = interaction.resizeRects.current\n  const inverted   = interaction.resizeRects.inverted\n  const deltaRect  = interaction.resizeRects.delta\n  const previous   = utils.extend(interaction.resizeRects.previous, inverted)\n  const originalEdges = edges\n\n  const eventDelta = utils.extend({}, iEvent.delta)\n\n  if (resizeOptions.preserveAspectRatio || resizeOptions.square) {\n    // `resize.preserveAspectRatio` takes precedence over `resize.square`\n    const startAspectRatio = resizeOptions.preserveAspectRatio\n      ? interaction.resizeStartAspectRatio\n      : 1\n\n    edges = interaction.prepared._linkedEdges\n\n    if ((originalEdges.left &amp;&amp; originalEdges.bottom) ||\n        (originalEdges.right &amp;&amp; originalEdges.top)) {\n      eventDelta.y = -eventDelta.x / startAspectRatio\n    }\n    else if (originalEdges.left || originalEdges.right) { eventDelta.y = eventDelta.x / startAspectRatio }\n    else if (originalEdges.top  || originalEdges.bottom) { eventDelta.x = eventDelta.y * startAspectRatio }\n  }\n\n  // update the \'current\' rect without modifications\n  if (edges.top) { current.top    += eventDelta.y }\n  if (edges.bottom) { current.bottom += eventDelta.y }\n  if (edges.left) { current.left   += eventDelta.x }\n  if (edges.right) { current.right  += eventDelta.x }\n\n  if (invertible) {\n    // if invertible, copy the current rect\n    utils.extend(inverted, current)\n\n    if (invert === \'reposition\') {\n      // swap edge values if necessary to keep width/height positive\n      let swap\n\n      if (inverted.top > inverted.bottom) {\n        swap = inverted.top\n\n        inverted.top = inverted.bottom\n        inverted.bottom = swap\n      }\n      if (inverted.left > inverted.right) {\n        swap = inverted.left\n\n        inverted.left = inverted.right\n        inverted.right = swap\n      }\n    }\n  }\n  else {\n    // if not invertible, restrict to minimum of 0x0 rect\n    inverted.top    = Math.min(current.top, start.bottom)\n    inverted.bottom = Math.max(current.bottom, start.top)\n    inverted.left   = Math.min(current.left, start.right)\n    inverted.right  = Math.max(current.right, start.left)\n  }\n\n  inverted.width  = inverted.right  - inverted.left\n  inverted.height = inverted.bottom - inverted.top\n\n  for (const edge in inverted) {\n    deltaRect[edge] = inverted[edge] - previous[edge]\n  }\n\n  iEvent.edges = interaction.prepared.edges\n  iEvent.rect = inverted\n  iEvent.deltaRect = deltaRect\n}\n\nfunction updateEventAxes ({ interaction, iEvent, action }) {\n  if (action !== \'resize\' || !interaction.resizeAxes) { return }\n\n  const options = interaction.interactable.options\n\n  if (options.resize.square) {\n    if (interaction.resizeAxes === \'y\') {\n      iEvent.delta.x = iEvent.delta.y\n    }\n    else {\n      iEvent.delta.y = iEvent.delta.x\n    }\n    iEvent.axes = \'xy\'\n  }\n  else {\n    iEvent.axes = interaction.resizeAxes\n\n    if (interaction.resizeAxes === \'x\') {\n      iEvent.delta.y = 0\n    }\n    else if (interaction.resizeAxes === \'y\') {\n      iEvent.delta.x = 0\n    }\n  }\n}\n\nexport default resize\n</code></pre>\n        </article>\n    </section>\n\n\n\n\n'}}]);
//# sourceMappingURL=chunk-2d0b3109.b4e33885.js.map