(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d208c3b"],{a5d5:function(e,n){e.exports='<nav class="jsdoc-nav">\n<li class="nav-link nav-home-link"><a href="/docs/api/index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="DropEvent.html">DropEvent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DropEvent.html#reject">reject</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Interactable.html">Interactable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#context">context</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#deltaSource">deltaSource</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#draggable">draggable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropCheck">dropCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropzone">dropzone</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#fire">fire</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#gesturable">gesturable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#getRect">getRect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#off">off</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#on">on</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#origin">origin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#rectChecker">rectChecker</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#reflow">reflow</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#resizable">resizable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#set">set</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#unset">unset</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="InteractEvent_InteractEvent.html">InteractEvent</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module.exports.html">exports</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-interact.html">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-interact.html#.maxInteractions">maxInteractions</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-modifiers_snapEdges.html">modifiers/snapEdges</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#interact">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#preventDefault">preventDefault</a></span></li>\n</nav>\n\n\n<h1 class="page-title">/actions/drop/index.ts</h1>\n\n\n\n\n\n\n    \n    <section>\n        <article>\n            <pre class="prettyprint source linenums"><code>import Interactable from \'@interactjs/core/Interactable\'\nimport InteractEvent from \'@interactjs/core/InteractEvent\'\nimport { Scope } from \'@interactjs/core/scope\'\nimport * as utils from \'@interactjs/utils\'\nimport drag from \'../drag\'\nimport DropEvent from \'./DropEvent\'\n\nexport interface DropzoneMethod {\n  (options: Interact.DropzoneOptions | boolean): Interact.Interactable\n  (): Interact.DropzoneOptions\n}\n\ndeclare module \'@interactjs/core/Interactable\' {\n  interface Interactable {\n    dropzone: DropzoneMethod\n    dropCheck: (\n      dragEvent: InteractEvent,\n      event: Interact.PointerEventType,\n      draggable: Interactable,\n      draggableElement: Element,\n      dropElemen: Element,\n      rect: any\n    ) => boolean\n  }\n}\n\ndeclare module \'@interactjs/core/Interaction\' {\n  interface Interaction {\n    dropState?: {\n      cur: {\n        dropzone: Interactable,   // the dropzone a drag target might be dropped into\n        element: Element,         // the element at the time of checking\n      },\n      prev: {\n        dropzone: Interactable,   // the dropzone that was recently dragged away from\n        element: Element,         // the element at the time of checking\n      },\n      rejected: boolean,          // wheather the potential drop was rejected from a listener\n      events: any,                // the drop events related to the current drag event\n      activeDrops: Array&lt;{\n        dropzone: Interactable\n        element: Element\n        rect: Interact.Rect\n      }>,\n    }\n  }\n}\n\ndeclare module \'@interactjs/core/defaultOptions\' {\n  interface ActionDefaults {\n    drop: Interact.DropzoneOptions\n  }\n}\n\ndeclare module \'@interactjs/core/scope\' {\n  interface Scope {\n    dynamicDrop?: boolean\n  }\n}\n\ndeclare module \'@interactjs/interact/interact\' {\n  interface InteractStatic {\n    dynamicDrop: (newValue?: boolean) => boolean | Interact.interact\n  }\n}\n\nfunction install (scope: Scope) {\n  const {\n    actions,\n    /** @lends module:interact */\n    interact,\n    /** @lends Interactable */\n    Interactable, // eslint-disable-line no-shadow\n    interactions,\n    defaults,\n  } = scope\n\n  scope.usePlugin(drag)\n\n  interactions.signals.on(\'before-action-start\', ({ interaction }) => {\n    if (interaction.prepared.name !== \'drag\') { return }\n\n    interaction.dropState = {\n      cur: {\n        dropzone: null,\n        element: null,\n      },\n      prev: {\n        dropzone: null,\n        element: null,\n      },\n      rejected: null,\n      events: null,\n      activeDrops: null,\n    }\n  })\n\n  interactions.signals.on(\'after-action-start\', ({ interaction, event, iEvent: dragEvent }) => {\n    if (interaction.prepared.name !== \'drag\') { return }\n\n    const { dropState } = interaction\n\n    // reset active dropzones\n    dropState.activeDrops = null\n    dropState.events = null\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n    dropState.events = getDropEvents(interaction, event, dragEvent)\n\n    if (dropState.events.activate) {\n      fireActivationEvents(dropState.activeDrops, dropState.events.activate)\n    }\n  })\n\n  // FIXME proper signal types\n  interactions.signals.on(\'action-move\', (arg) => onEventCreated(arg as any, scope))\n  interactions.signals.on(\'action-end\', (arg) => onEventCreated(arg as any, scope))\n\n  interactions.signals.on(\'after-action-move\', ({ interaction }) => {\n    if (interaction.prepared.name !== \'drag\') { return }\n\n    fireDropEvents(interaction, interaction.dropState.events)\n    interaction.dropState.events = {}\n  })\n\n  interactions.signals.on(\'after-action-end\', ({ interaction }) => {\n    if (interaction.prepared.name !== \'drag\') { return }\n\n    fireDropEvents(interaction, interaction.dropState.events)\n  })\n\n  interactions.signals.on(\'stop\', ({ interaction }) => {\n    if (interaction.prepared.name !== \'drag\') { return }\n\n    const { dropState } = interaction\n\n    dropState.activeDrops = null\n    dropState.events = null\n    dropState.cur.dropzone = null\n    dropState.cur.element = null\n    dropState.prev.dropzone = null\n    dropState.prev.element = null\n    dropState.rejected = false\n  })\n\n  /**\n   *\n   * ```js\n   * interact(\'.drop\').dropzone({\n   *   accept: \'.can-drop\' || document.getElementById(\'single-drop\'),\n   *   overlap: \'pointer\' || \'center\' || zeroToOne\n   * }\n   * ```\n   *\n   * Returns or sets whether draggables can be dropped onto this target to\n   * trigger drop events\n   *\n   * Dropzones can receive the following events:\n   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n   *  - `dragmove` when a draggable that has entered the dropzone is moved\n   *  - `drop` when a draggable is dropped into this dropzone\n   *\n   * Use the `accept` option to allow only elements that match the given CSS\n   * selector or element. The value can be:\n   *\n   *  - **an Element** - only that element can be dropped into this dropzone.\n   *  - **a string**, - the element being dragged must match it as a CSS selector.\n   *  - **`null`** - accept options is cleared - it accepts any element.\n   *\n   * Use the `overlap` option to set how drops are checked for. The allowed\n   * values are:\n   *\n   *   - `\'pointer\'`, the pointer must be over the dropzone (default)\n   *   - `\'center\'`, the draggable element\'s center must be over the dropzone\n   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n   *   e.g. `0.5` for drop to happen when half of the area of the draggable is\n   *   over the dropzone\n   *\n   * Use the `checker` option to specify a function to check if a dragged element\n   * is over this Interactable.\n   *\n   * @param {boolean | object | null} [options] The new options to be set.\n   * @return {boolean | Interactable} The current setting or this Interactable\n   */\n  Interactable.prototype.dropzone = function (this: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n    return dropzoneMethod(this, options)\n  }\n\n  /**\n   * ```js\n   * interact(target)\n   * .dropChecker(function(dragEvent,         // related dragmove or dragend event\n   *                       event,             // TouchEvent/PointerEvent/MouseEvent\n   *                       dropped,           // bool result of the default checker\n   *                       dropzone,          // dropzone Interactable\n   *                       dropElement,       // dropzone elemnt\n   *                       draggable,         // draggable Interactable\n   *                       draggableElement) {// draggable element\n   *\n   *   return dropped &amp;&amp; event.target.hasAttribute(\'allow-drop\')\n   * }\n   * ```\n   */\n  Interactable.prototype.dropCheck = function (this: Interact.Interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {\n    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)\n  }\n\n  /**\n   * Returns or sets whether the dimensions of dropzone elements are calculated\n   * on every dragmove or only on dragstart for the default dropChecker\n   *\n   * @param {boolean} [newValue] True to check on each move. False to check only\n   * before start\n   * @return {boolean | interact} The current setting or interact\n   */\n  interact.dynamicDrop = function (newValue?: boolean) {\n    if (utils.is.bool(newValue)) {\n      // if (dragging &amp;&amp; scope.dynamicDrop !== newValue &amp;&amp; !newValue) {\n      //  calcRects(dropzones)\n      // }\n\n      scope.dynamicDrop = newValue\n\n      return interact\n    }\n    return scope.dynamicDrop\n  }\n\n  utils.arr.merge(actions.eventTypes, [\n    \'dragenter\',\n    \'dragleave\',\n    \'dropactivate\',\n    \'dropdeactivate\',\n    \'dropmove\',\n    \'drop\',\n  ])\n  actions.methodDict.drop = \'dropzone\'\n\n  scope.dynamicDrop = false\n\n  defaults.actions.drop = drop.defaults\n}\n\nfunction collectDrops ({ interactables }, draggableElement) {\n  const drops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const dropzone of interactables.list) {\n    if (!dropzone.options.drop.enabled) { continue }\n\n    const accept = dropzone.options.drop.accept\n\n    // test the draggable draggableElement against the dropzone\'s accept setting\n    if ((utils.is.element(accept) &amp;&amp; accept !== draggableElement) ||\n        (utils.is.string(accept) &amp;&amp;\n        !utils.dom.matchesSelector(draggableElement, accept)) ||\n        (utils.is.func(accept) &amp;&amp; !accept({ dropzone, draggableElement }))) {\n      continue\n    }\n\n    // query for new elements if necessary\n    const dropElements = utils.is.string(dropzone.target)\n      ? dropzone._context.querySelectorAll(dropzone.target)\n      : utils.is.array(dropzone.target) ? dropzone.target : [dropzone.target]\n\n    for (const dropzoneElement of dropElements) {\n      if (dropzoneElement !== draggableElement) {\n        drops.push({\n          dropzone,\n          element: dropzoneElement,\n        })\n      }\n    }\n  }\n\n  return drops\n}\n\nfunction fireActivationEvents (activeDrops, event) {\n  // loop through all active dropzones and trigger event\n  for (const { dropzone, element } of activeDrops) {\n    event.dropzone = dropzone\n\n    // set current element as event target\n    event.target = element\n    dropzone.fire(event)\n    event.propagationStopped = event.immediatePropagationStopped = false\n  }\n}\n\n// return a new array of possible drops. getActiveDrops should always be\n// called when a drag has just started or a drag event happens while\n// dynamicDrop is true\nfunction getActiveDrops (scope: Scope, dragElement: Element) {\n  // get dropzones and their elements that could receive the draggable\n  const activeDrops = collectDrops(scope, dragElement)\n\n  for (const activeDrop of activeDrops) {\n    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)\n  }\n\n  return activeDrops\n}\n\nfunction getDrop ({ dropState, interactable: draggable, element: dragElement }: Partial&lt;Interact.Interaction>, dragEvent, pointerEvent) {\n  const validDrops = []\n\n  // collect all dropzones and their elements which qualify for a drop\n  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {\n    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)\n      ? dropzoneElement\n      : null)\n  }\n\n  // get the most appropriate dropzone based on DOM depth and order\n  const dropIndex = utils.dom.indexOfDeepestElement(validDrops)\n\n  return dropState.activeDrops[dropIndex] || null\n}\n\nfunction getDropEvents (interaction: Interact.Interaction, _pointerEvent, dragEvent) {\n  const { dropState } = interaction\n  const dropEvents = {\n    enter     : null,\n    leave     : null,\n    activate  : null,\n    deactivate: null,\n    move      : null,\n    drop      : null,\n  }\n\n  if (dragEvent.type === \'dragstart\') {\n    dropEvents.activate = new DropEvent(dropState, dragEvent, \'dropactivate\')\n\n    dropEvents.activate.target   = null\n    dropEvents.activate.dropzone = null\n  }\n  if (dragEvent.type === \'dragend\') {\n    dropEvents.deactivate = new DropEvent(dropState, dragEvent, \'dropdeactivate\')\n\n    dropEvents.deactivate.target   = null\n    dropEvents.deactivate.dropzone = null\n  }\n\n  if (dropState.rejected) {\n    return dropEvents\n  }\n\n  if (dropState.cur.element !== dropState.prev.element) {\n    // if there was a previous dropzone, create a dragleave event\n    if (dropState.prev.dropzone) {\n      dropEvents.leave = new DropEvent(dropState, dragEvent, \'dragleave\')\n\n      dragEvent.dragLeave    = dropEvents.leave.target   = dropState.prev.element\n      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone\n    }\n    // if dropzone is not null, create a dragenter event\n    if (dropState.cur.dropzone) {\n      dropEvents.enter = new DropEvent(dropState, dragEvent, \'dragenter\')\n\n      dragEvent.dragEnter = dropState.cur.element\n      dragEvent.dropzone = dropState.cur.dropzone\n    }\n  }\n\n  if (dragEvent.type === \'dragend\' &amp;&amp; dropState.cur.dropzone) {\n    dropEvents.drop = new DropEvent(dropState, dragEvent, \'drop\')\n\n    dragEvent.dropzone = dropState.cur.dropzone\n    dragEvent.relatedTarget = dropState.cur.element\n  }\n  if (dragEvent.type === \'dragmove\' &amp;&amp; dropState.cur.dropzone) {\n    dropEvents.move = new DropEvent(dropState, dragEvent, \'dropmove\')\n\n    dropEvents.move.dragmove = dragEvent\n    dragEvent.dropzone = dropState.cur.dropzone\n  }\n\n  return dropEvents\n}\n\nfunction fireDropEvents (interaction: Interact.Interaction, events) {\n  const { dropState } = interaction\n  const {\n    activeDrops,\n    cur,\n    prev,\n  } = dropState\n\n  if (events.leave) { prev.dropzone.fire(events.leave) }\n  if (events.move) { cur.dropzone.fire(events.move) }\n  if (events.enter) { cur.dropzone.fire(events.enter) }\n  if (events.drop) { cur.dropzone.fire(events.drop) }\n\n  if (events.deactivate) {\n    fireActivationEvents(activeDrops, events.deactivate)\n  }\n\n  dropState.prev.dropzone  = cur.dropzone\n  dropState.prev.element = cur.element\n}\n\nfunction onEventCreated ({ interaction, iEvent, event }: Interact.SignalArg, scope) {\n  if (iEvent.type !== \'dragmove\' &amp;&amp; iEvent.type !== \'dragend\') { return }\n\n  const { dropState } = interaction\n\n  if (scope.dynamicDrop) {\n    dropState.activeDrops = getActiveDrops(scope, interaction.element)\n  }\n\n  const dragEvent = iEvent\n  const dropResult = getDrop(interaction, dragEvent, event)\n\n  // update rejected status\n  dropState.rejected = dropState.rejected &amp;&amp;\n    !!dropResult &amp;&amp;\n    dropResult.dropzone === dropState.cur.dropzone &amp;&amp;\n    dropResult.element === dropState.cur.element\n\n  dropState.cur.dropzone  = dropResult &amp;&amp; dropResult.dropzone\n  dropState.cur.element = dropResult &amp;&amp; dropResult.element\n\n  dropState.events = getDropEvents(interaction, event, dragEvent)\n}\n\nfunction dropzoneMethod (interactable: Interact.Interactable): Interact.DropzoneOptions\nfunction dropzoneMethod (interactable: Interact.Interactable, options: Interact.DropzoneOptions | boolean)\nfunction dropzoneMethod (interactable: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {\n  if (utils.is.object(options)) {\n    interactable.options.drop.enabled = options.enabled !== false\n\n    if (options.listeners) {\n      const normalized = utils.normalizeListeners(options.listeners)\n      // rename \'drop\' to \'\' as it will be prefixed with \'drop\'\n      const corrected = Object.keys(normalized).reduce((acc, type) => {\n        const correctedType = /^(enter|leave)/.test(type)\n          ? `drag${type}`\n          : /^(activate|deactivate|move)/.test(type)\n            ? `drop${type}`\n            : type\n\n        acc[correctedType] = normalized[type]\n\n        return acc\n      }, {})\n\n      interactable.off(interactable.options.drop.listeners)\n      interactable.on(corrected)\n      interactable.options.drop.listeners = corrected\n    }\n\n    if (utils.is.func(options.ondrop)) { interactable.on(\'drop\', options.ondrop) }\n    if (utils.is.func(options.ondropactivate)) { interactable.on(\'dropactivate\', options.ondropactivate) }\n    if (utils.is.func(options.ondropdeactivate)) { interactable.on(\'dropdeactivate\', options.ondropdeactivate) }\n    if (utils.is.func(options.ondragenter)) { interactable.on(\'dragenter\', options.ondragenter) }\n    if (utils.is.func(options.ondragleave)) { interactable.on(\'dragleave\', options.ondragleave) }\n    if (utils.is.func(options.ondropmove)) { interactable.on(\'dropmove\', options.ondropmove) }\n\n    if (/^(pointer|center)$/.test(options.overlap as string)) {\n      interactable.options.drop.overlap = options.overlap\n    }\n    else if (utils.is.number(options.overlap)) {\n      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)\n    }\n    if (\'accept\' in options) {\n      interactable.options.drop.accept = options.accept\n    }\n    if (\'checker\' in options) {\n      interactable.options.drop.checker = options.checker\n    }\n\n    return interactable\n  }\n\n  if (utils.is.bool(options)) {\n    interactable.options.drop.enabled = options\n\n    return interactable\n  }\n\n  return interactable.options.drop\n}\n\nfunction dropCheckMethod (\n  interactable: Interact.Interactable,\n  dragEvent: InteractEvent,\n  event: Interact.PointerEventType,\n  draggable: Interact.Interactable,\n  draggableElement: Element,\n  dropElement: Element,\n  rect: any\n) {\n  let dropped = false\n\n  // if the dropzone has no rect (eg. display: none)\n  // call the custom dropChecker or just return false\n  if (!(rect = rect || interactable.getRect(dropElement))) {\n    return (interactable.options.drop.checker\n      ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n      : false)\n  }\n\n  const dropOverlap = interactable.options.drop.overlap\n\n  if (dropOverlap === \'pointer\') {\n    const origin = utils.getOriginXY(draggable, draggableElement, \'drag\')\n    const page = utils.pointer.getPageXY(dragEvent)\n\n    page.x += origin.x\n    page.y += origin.y\n\n    const horizontal = (page.x > rect.left) &amp;&amp; (page.x &lt; rect.right)\n    const vertical   = (page.y > rect.top) &amp;&amp; (page.y &lt; rect.bottom)\n\n    dropped = horizontal &amp;&amp; vertical\n  }\n\n  const dragRect = draggable.getRect(draggableElement)\n\n  if (dragRect &amp;&amp; dropOverlap === \'center\') {\n    const cx = dragRect.left + dragRect.width  / 2\n    const cy = dragRect.top  + dragRect.height / 2\n\n    dropped = cx >= rect.left &amp;&amp; cx &lt;= rect.right &amp;&amp; cy >= rect.top &amp;&amp; cy &lt;= rect.bottom\n  }\n\n  if (dragRect &amp;&amp; utils.is.number(dropOverlap)) {\n    const overlapArea  = (Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *\n                          Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)))\n\n    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)\n\n    dropped = overlapRatio >= dropOverlap\n  }\n\n  if (interactable.options.drop.checker) {\n    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)\n  }\n\n  return dropped\n}\n\nconst drop = {\n  id: \'actions/drop\',\n  install,\n  getActiveDrops,\n  getDrop,\n  getDropEvents,\n  fireDropEvents,\n  defaults: {\n    enabled: false,\n    accept : null,\n    overlap: \'pointer\',\n  } as Interact.DropzoneOptions,\n}\n\nexport default drop\n</code></pre>\n        </article>\n    </section>\n\n\n\n\n'}}]);
//# sourceMappingURL=chunk-2d208c3b.7a2ff5c6.js.map