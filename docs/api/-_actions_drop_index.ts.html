<!DOCTYPE html><html lang="en" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta content="IE=edge" http-equiv="X-UA-Compatible"><meta content="width=device-width,initial-scale=1" name="viewport"><meta content="#213544" name="theme-color"><link href="/img/ijs-64.png" rel="icon" type="image/png"><title>interact.js</title><link href="/css/router.2e052cdd.css" rel="prefetch"><link href="/js/LiveDemo.e04945e4.js" rel="prefetch"><link href="/js/chunk-2956840e.f9860c6f.js" rel="prefetch"><link href="/js/chunk-2d0a406a.5688e2c4.js" rel="prefetch"><link href="/js/chunk-2d0a4974.32073039.js" rel="prefetch"><link href="/js/chunk-2d0a4f63.d0f51339.js" rel="prefetch"><link href="/js/chunk-2d0aabd1.b7e78600.js" rel="prefetch"><link href="/js/chunk-2d0af0ab.13972c8f.js" rel="prefetch"><link href="/js/chunk-2d0af0ed.d8cccf2d.js" rel="prefetch"><link href="/js/chunk-2d0b3109.b4e33885.js" rel="prefetch"><link href="/js/chunk-2d0b6737.cb8b577b.js" rel="prefetch"><link href="/js/chunk-2d0b93c6.d469d460.js" rel="prefetch"><link href="/js/chunk-2d0ba364.47f87269.js" rel="prefetch"><link href="/js/chunk-2d0bdd6b.42358faa.js" rel="prefetch"><link href="/js/chunk-2d0c4a60.f80ba89f.js" rel="prefetch"><link href="/js/chunk-2d0c73d0.aa5cab2f.js" rel="prefetch"><link href="/js/chunk-2d0d3104.76e9e9c2.js" rel="prefetch"><link href="/js/chunk-2d0d7295.4cf90d27.js" rel="prefetch"><link href="/js/chunk-2d0da6d5.e5a58998.js" rel="prefetch"><link href="/js/chunk-2d0da7cf.11b98c10.js" rel="prefetch"><link href="/js/chunk-2d0de1ce.7bcb4e2f.js" rel="prefetch"><link href="/js/chunk-2d0deeb3.5890f416.js" rel="prefetch"><link href="/js/chunk-2d0e2374.7790a5ca.js" rel="prefetch"><link href="/js/chunk-2d0e8e5d.0dbb061c.js" rel="prefetch"><link href="/js/chunk-2d0f028d.3bc47590.js" rel="prefetch"><link href="/js/chunk-2d0f0b62.6528bc71.js" rel="prefetch"><link href="/js/chunk-2d208c3b.7a2ff5c6.js" rel="prefetch"><link href="/js/chunk-2d20ee22.dfa46035.js" rel="prefetch"><link href="/js/chunk-2d2105b4.f2f202f7.js" rel="prefetch"><link href="/js/chunk-2d2134e9.fbd23b79.js" rel="prefetch"><link href="/js/chunk-2d213ed9.f4e60027.js" rel="prefetch"><link href="/js/chunk-2d21764a.ddd7afbf.js" rel="prefetch"><link href="/js/chunk-2d21789d.b5bdeded.js" rel="prefetch"><link href="/js/chunk-2d217c4d.f81fed21.js" rel="prefetch"><link href="/js/chunk-2d2219c8.caf3fa8c.js" rel="prefetch"><link href="/js/chunk-2d221bb3.c20987de.js" rel="prefetch"><link href="/js/chunk-2d221bba.ce62afec.js" rel="prefetch"><link href="/js/chunk-2d238035.de00af4c.js" rel="prefetch"><link href="/js/chunk-7d4ab821.2316070d.js" rel="prefetch"><link href="/js/home-demos.3fd11deb.js" rel="prefetch"><link href="/js/router.c729c9b0.js" rel="prefetch"><link href="/css/app.c51a2055.css" rel="preload" as="style"><link href="/css/chunk-vendors.6845127f.css" rel="preload" as="style"><link href="/js/app.6102e1da.js" rel="preload" as="script"><link href="/js/chunk-vendors.c6aabe48.js" rel="preload" as="script"><link href="/css/chunk-vendors.6845127f.css" rel="stylesheet"><link href="/css/app.c51a2055.css" rel="stylesheet"><link href="/css/router.2e052cdd.css" rel="stylesheet" type="text/css"><script src="/js/router.c729c9b0.js" charset="utf-8"></script><script src="/js/chunk-2d208c3b.7a2ff5c6.js" charset="utf-8"></script></head><body><div id="app" data-server-rendered="true"><a class="" id="nav-button"><span>NAV <img src="data:image/png;base64,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"></span></a><div class="tocify-wrapper"><a href="/" class="router-link-active"><img src="/img/ijs.3508950a.svg" alt="interact.js" class="logo" title="homepage"></a><div class="has-text-centered"><a href="https://www.npmjs.com/package/interactjs/v/undefined" class="version-badge tags has-addons is-inline-flex" style="visibility: hidden; opacity: 0;"><span class="tag is-light">version</span><span class="tag is-success"></span></a></div><nav class="jsdoc-nav"><li class="nav-link nav-home-link"><a href="/docs/api/index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="DropEvent.html">DropEvent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="DropEvent.html#reject">reject</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Interactable.html">Interactable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#context">context</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#deltaSource">deltaSource</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#draggable">draggable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropCheck">dropCheck</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#dropzone">dropzone</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#fire">fire</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#gesturable">gesturable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#getRect">getRect</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#off">off</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#on">on</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#origin">origin</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#rectChecker">rectChecker</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#reflow">reflow</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#resizable">resizable</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#set">set</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Interactable.html#unset">unset</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="InteractEvent_InteractEvent.html">InteractEvent</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="module.exports.html">exports</a></span></li><li class="nav-heading">Modules</li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-interact.html">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="module-interact.html#.maxInteractions">maxInteractions</a></span></li><li class="nav-heading"><span class="nav-item-type type-module">M</span><span class="nav-item-name"><a href="module-modifiers_snapEdges.html">modifiers/snapEdges</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-member">M</span><span class="nav-item-name"><a href="global.html#interact">interact</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#preventDefault">preventDefault</a></span></li></nav></div><div class="page-wrapper"><div class="jsdoc-content jsdoc-content" id="main"><h1 class="page-title title is-2">/actions/drop/index.ts</h1><section><article><pre class="prettyprint source linenums"><code>import Interactable from '@interactjs/core/Interactable'
import InteractEvent from '@interactjs/core/InteractEvent'
import { Scope } from '@interactjs/core/scope'
import * as utils from '@interactjs/utils'
import drag from '../drag'
import DropEvent from './DropEvent'

export interface DropzoneMethod {
  (options: Interact.DropzoneOptions | boolean): Interact.Interactable
  (): Interact.DropzoneOptions
}

declare module '@interactjs/core/Interactable' {
  interface Interactable {
    dropzone: DropzoneMethod
    dropCheck: (
      dragEvent: InteractEvent,
      event: Interact.PointerEventType,
      draggable: Interactable,
      draggableElement: Element,
      dropElemen: Element,
      rect: any
    ) => boolean
  }
}

declare module '@interactjs/core/Interaction' {
  interface Interaction {
    dropState?: {
      cur: {
        dropzone: Interactable,   // the dropzone a drag target might be dropped into
        element: Element,         // the element at the time of checking
      },
      prev: {
        dropzone: Interactable,   // the dropzone that was recently dragged away from
        element: Element,         // the element at the time of checking
      },
      rejected: boolean,          // wheather the potential drop was rejected from a listener
      events: any,                // the drop events related to the current drag event
      activeDrops: Array&lt;{
        dropzone: Interactable
        element: Element
        rect: Interact.Rect
      }>,
    }
  }
}

declare module '@interactjs/core/defaultOptions' {
  interface ActionDefaults {
    drop: Interact.DropzoneOptions
  }
}

declare module '@interactjs/core/scope' {
  interface Scope {
    dynamicDrop?: boolean
  }
}

declare module '@interactjs/interact/interact' {
  interface InteractStatic {
    dynamicDrop: (newValue?: boolean) => boolean | Interact.interact
  }
}

function install (scope: Scope) {
  const {
    actions,
    /** @lends module:interact */
    interact,
    /** @lends Interactable */
    Interactable, // eslint-disable-line no-shadow
    interactions,
    defaults,
  } = scope

  scope.usePlugin(drag)

  interactions.signals.on('before-action-start', ({ interaction }) => {
    if (interaction.prepared.name !== 'drag') { return }

    interaction.dropState = {
      cur: {
        dropzone: null,
        element: null,
      },
      prev: {
        dropzone: null,
        element: null,
      },
      rejected: null,
      events: null,
      activeDrops: null,
    }
  })

  interactions.signals.on('after-action-start', ({ interaction, event, iEvent: dragEvent }) => {
    if (interaction.prepared.name !== 'drag') { return }

    const { dropState } = interaction

    // reset active dropzones
    dropState.activeDrops = null
    dropState.events = null
    dropState.activeDrops = getActiveDrops(scope, interaction.element)
    dropState.events = getDropEvents(interaction, event, dragEvent)

    if (dropState.events.activate) {
      fireActivationEvents(dropState.activeDrops, dropState.events.activate)
    }
  })

  // FIXME proper signal types
  interactions.signals.on('action-move', (arg) => onEventCreated(arg as any, scope))
  interactions.signals.on('action-end', (arg) => onEventCreated(arg as any, scope))

  interactions.signals.on('after-action-move', ({ interaction }) => {
    if (interaction.prepared.name !== 'drag') { return }

    fireDropEvents(interaction, interaction.dropState.events)
    interaction.dropState.events = {}
  })

  interactions.signals.on('after-action-end', ({ interaction }) => {
    if (interaction.prepared.name !== 'drag') { return }

    fireDropEvents(interaction, interaction.dropState.events)
  })

  interactions.signals.on('stop', ({ interaction }) => {
    if (interaction.prepared.name !== 'drag') { return }

    const { dropState } = interaction

    dropState.activeDrops = null
    dropState.events = null
    dropState.cur.dropzone = null
    dropState.cur.element = null
    dropState.prev.dropzone = null
    dropState.prev.element = null
    dropState.rejected = false
  })

  /**
   *
   * ```js
   * interact('.drop').dropzone({
   *   accept: '.can-drop' || document.getElementById('single-drop'),
   *   overlap: 'pointer' || 'center' || zeroToOne
   * }
   * ```
   *
   * Returns or sets whether draggables can be dropped onto this target to
   * trigger drop events
   *
   * Dropzones can receive the following events:
   *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends
   *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone
   *  - `dragmove` when a draggable that has entered the dropzone is moved
   *  - `drop` when a draggable is dropped into this dropzone
   *
   * Use the `accept` option to allow only elements that match the given CSS
   * selector or element. The value can be:
   *
   *  - **an Element** - only that element can be dropped into this dropzone.
   *  - **a string**, - the element being dragged must match it as a CSS selector.
   *  - **`null`** - accept options is cleared - it accepts any element.
   *
   * Use the `overlap` option to set how drops are checked for. The allowed
   * values are:
   *
   *   - `'pointer'`, the pointer must be over the dropzone (default)
   *   - `'center'`, the draggable element's center must be over the dropzone
   *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.
   *   e.g. `0.5` for drop to happen when half of the area of the draggable is
   *   over the dropzone
   *
   * Use the `checker` option to specify a function to check if a dragged element
   * is over this Interactable.
   *
   * @param {boolean | object | null} [options] The new options to be set.
   * @return {boolean | Interactable} The current setting or this Interactable
   */
  Interactable.prototype.dropzone = function (this: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {
    return dropzoneMethod(this, options)
  }

  /**
   * ```js
   * interact(target)
   * .dropChecker(function(dragEvent,         // related dragmove or dragend event
   *                       event,             // TouchEvent/PointerEvent/MouseEvent
   *                       dropped,           // bool result of the default checker
   *                       dropzone,          // dropzone Interactable
   *                       dropElement,       // dropzone elemnt
   *                       draggable,         // draggable Interactable
   *                       draggableElement) {// draggable element
   *
   *   return dropped && event.target.hasAttribute('allow-drop')
   * }
   * ```
   */
  Interactable.prototype.dropCheck = function (this: Interact.Interactable, dragEvent, event, draggable, draggableElement, dropElement, rect) {
    return dropCheckMethod(this, dragEvent, event, draggable, draggableElement, dropElement, rect)
  }

  /**
   * Returns or sets whether the dimensions of dropzone elements are calculated
   * on every dragmove or only on dragstart for the default dropChecker
   *
   * @param {boolean} [newValue] True to check on each move. False to check only
   * before start
   * @return {boolean | interact} The current setting or interact
   */
  interact.dynamicDrop = function (newValue?: boolean) {
    if (utils.is.bool(newValue)) {
      // if (dragging && scope.dynamicDrop !== newValue && !newValue) {
      //  calcRects(dropzones)
      // }

      scope.dynamicDrop = newValue

      return interact
    }
    return scope.dynamicDrop
  }

  utils.arr.merge(actions.eventTypes, [
    'dragenter',
    'dragleave',
    'dropactivate',
    'dropdeactivate',
    'dropmove',
    'drop',
  ])
  actions.methodDict.drop = 'dropzone'

  scope.dynamicDrop = false

  defaults.actions.drop = drop.defaults
}

function collectDrops ({ interactables }, draggableElement) {
  const drops = []

  // collect all dropzones and their elements which qualify for a drop
  for (const dropzone of interactables.list) {
    if (!dropzone.options.drop.enabled) { continue }

    const accept = dropzone.options.drop.accept

    // test the draggable draggableElement against the dropzone's accept setting
    if ((utils.is.element(accept) && accept !== draggableElement) ||
        (utils.is.string(accept) &&
        !utils.dom.matchesSelector(draggableElement, accept)) ||
        (utils.is.func(accept) && !accept({ dropzone, draggableElement }))) {
      continue
    }

    // query for new elements if necessary
    const dropElements = utils.is.string(dropzone.target)
      ? dropzone._context.querySelectorAll(dropzone.target)
      : utils.is.array(dropzone.target) ? dropzone.target : [dropzone.target]

    for (const dropzoneElement of dropElements) {
      if (dropzoneElement !== draggableElement) {
        drops.push({
          dropzone,
          element: dropzoneElement,
        })
      }
    }
  }

  return drops
}

function fireActivationEvents (activeDrops, event) {
  // loop through all active dropzones and trigger event
  for (const { dropzone, element } of activeDrops) {
    event.dropzone = dropzone

    // set current element as event target
    event.target = element
    dropzone.fire(event)
    event.propagationStopped = event.immediatePropagationStopped = false
  }
}

// return a new array of possible drops. getActiveDrops should always be
// called when a drag has just started or a drag event happens while
// dynamicDrop is true
function getActiveDrops (scope: Scope, dragElement: Element) {
  // get dropzones and their elements that could receive the draggable
  const activeDrops = collectDrops(scope, dragElement)

  for (const activeDrop of activeDrops) {
    activeDrop.rect = activeDrop.dropzone.getRect(activeDrop.element)
  }

  return activeDrops
}

function getDrop ({ dropState, interactable: draggable, element: dragElement }: Partial&lt;Interact.Interaction>, dragEvent, pointerEvent) {
  const validDrops = []

  // collect all dropzones and their elements which qualify for a drop
  for (const { dropzone, element: dropzoneElement, rect } of dropState.activeDrops) {
    validDrops.push(dropzone.dropCheck(dragEvent, pointerEvent, draggable, dragElement, dropzoneElement, rect)
      ? dropzoneElement
      : null)
  }

  // get the most appropriate dropzone based on DOM depth and order
  const dropIndex = utils.dom.indexOfDeepestElement(validDrops)

  return dropState.activeDrops[dropIndex] || null
}

function getDropEvents (interaction: Interact.Interaction, _pointerEvent, dragEvent) {
  const { dropState } = interaction
  const dropEvents = {
    enter     : null,
    leave     : null,
    activate  : null,
    deactivate: null,
    move      : null,
    drop      : null,
  }

  if (dragEvent.type === 'dragstart') {
    dropEvents.activate = new DropEvent(dropState, dragEvent, 'dropactivate')

    dropEvents.activate.target   = null
    dropEvents.activate.dropzone = null
  }
  if (dragEvent.type === 'dragend') {
    dropEvents.deactivate = new DropEvent(dropState, dragEvent, 'dropdeactivate')

    dropEvents.deactivate.target   = null
    dropEvents.deactivate.dropzone = null
  }

  if (dropState.rejected) {
    return dropEvents
  }

  if (dropState.cur.element !== dropState.prev.element) {
    // if there was a previous dropzone, create a dragleave event
    if (dropState.prev.dropzone) {
      dropEvents.leave = new DropEvent(dropState, dragEvent, 'dragleave')

      dragEvent.dragLeave    = dropEvents.leave.target   = dropState.prev.element
      dragEvent.prevDropzone = dropEvents.leave.dropzone = dropState.prev.dropzone
    }
    // if dropzone is not null, create a dragenter event
    if (dropState.cur.dropzone) {
      dropEvents.enter = new DropEvent(dropState, dragEvent, 'dragenter')

      dragEvent.dragEnter = dropState.cur.element
      dragEvent.dropzone = dropState.cur.dropzone
    }
  }

  if (dragEvent.type === 'dragend' && dropState.cur.dropzone) {
    dropEvents.drop = new DropEvent(dropState, dragEvent, 'drop')

    dragEvent.dropzone = dropState.cur.dropzone
    dragEvent.relatedTarget = dropState.cur.element
  }
  if (dragEvent.type === 'dragmove' && dropState.cur.dropzone) {
    dropEvents.move = new DropEvent(dropState, dragEvent, 'dropmove')

    dropEvents.move.dragmove = dragEvent
    dragEvent.dropzone = dropState.cur.dropzone
  }

  return dropEvents
}

function fireDropEvents (interaction: Interact.Interaction, events) {
  const { dropState } = interaction
  const {
    activeDrops,
    cur,
    prev,
  } = dropState

  if (events.leave) { prev.dropzone.fire(events.leave) }
  if (events.move) { cur.dropzone.fire(events.move) }
  if (events.enter) { cur.dropzone.fire(events.enter) }
  if (events.drop) { cur.dropzone.fire(events.drop) }

  if (events.deactivate) {
    fireActivationEvents(activeDrops, events.deactivate)
  }

  dropState.prev.dropzone  = cur.dropzone
  dropState.prev.element = cur.element
}

function onEventCreated ({ interaction, iEvent, event }: Interact.SignalArg, scope) {
  if (iEvent.type !== 'dragmove' && iEvent.type !== 'dragend') { return }

  const { dropState } = interaction

  if (scope.dynamicDrop) {
    dropState.activeDrops = getActiveDrops(scope, interaction.element)
  }

  const dragEvent = iEvent
  const dropResult = getDrop(interaction, dragEvent, event)

  // update rejected status
  dropState.rejected = dropState.rejected &&
    !!dropResult &&
    dropResult.dropzone === dropState.cur.dropzone &&
    dropResult.element === dropState.cur.element

  dropState.cur.dropzone  = dropResult && dropResult.dropzone
  dropState.cur.element = dropResult && dropResult.element

  dropState.events = getDropEvents(interaction, event, dragEvent)
}

function dropzoneMethod (interactable: Interact.Interactable): Interact.DropzoneOptions
function dropzoneMethod (interactable: Interact.Interactable, options: Interact.DropzoneOptions | boolean)
function dropzoneMethod (interactable: Interact.Interactable, options?: Interact.DropzoneOptions | boolean) {
  if (utils.is.object(options)) {
    interactable.options.drop.enabled = options.enabled !== false

    if (options.listeners) {
      const normalized = utils.normalizeListeners(options.listeners)
      // rename 'drop' to '' as it will be prefixed with 'drop'
      const corrected = Object.keys(normalized).reduce((acc, type) => {
        const correctedType = /^(enter|leave)/.test(type)
          ? `drag${type}`
          : /^(activate|deactivate|move)/.test(type)
            ? `drop${type}`
            : type

        acc[correctedType] = normalized[type]

        return acc
      }, {})

      interactable.off(interactable.options.drop.listeners)
      interactable.on(corrected)
      interactable.options.drop.listeners = corrected
    }

    if (utils.is.func(options.ondrop)) { interactable.on('drop', options.ondrop) }
    if (utils.is.func(options.ondropactivate)) { interactable.on('dropactivate', options.ondropactivate) }
    if (utils.is.func(options.ondropdeactivate)) { interactable.on('dropdeactivate', options.ondropdeactivate) }
    if (utils.is.func(options.ondragenter)) { interactable.on('dragenter', options.ondragenter) }
    if (utils.is.func(options.ondragleave)) { interactable.on('dragleave', options.ondragleave) }
    if (utils.is.func(options.ondropmove)) { interactable.on('dropmove', options.ondropmove) }

    if (/^(pointer|center)$/.test(options.overlap as string)) {
      interactable.options.drop.overlap = options.overlap
    }
    else if (utils.is.number(options.overlap)) {
      interactable.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0)
    }
    if ('accept' in options) {
      interactable.options.drop.accept = options.accept
    }
    if ('checker' in options) {
      interactable.options.drop.checker = options.checker
    }

    return interactable
  }

  if (utils.is.bool(options)) {
    interactable.options.drop.enabled = options

    return interactable
  }

  return interactable.options.drop
}

function dropCheckMethod (
  interactable: Interact.Interactable,
  dragEvent: InteractEvent,
  event: Interact.PointerEventType,
  draggable: Interact.Interactable,
  draggableElement: Element,
  dropElement: Element,
  rect: any
) {
  let dropped = false

  // if the dropzone has no rect (eg. display: none)
  // call the custom dropChecker or just return false
  if (!(rect = rect || interactable.getRect(dropElement))) {
    return (interactable.options.drop.checker
      ? interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)
      : false)
  }

  const dropOverlap = interactable.options.drop.overlap

  if (dropOverlap === 'pointer') {
    const origin = utils.getOriginXY(draggable, draggableElement, 'drag')
    const page = utils.pointer.getPageXY(dragEvent)

    page.x += origin.x
    page.y += origin.y

    const horizontal = (page.x > rect.left) && (page.x &lt; rect.right)
    const vertical   = (page.y > rect.top) && (page.y &lt; rect.bottom)

    dropped = horizontal && vertical
  }

  const dragRect = draggable.getRect(draggableElement)

  if (dragRect && dropOverlap === 'center') {
    const cx = dragRect.left + dragRect.width  / 2
    const cy = dragRect.top  + dragRect.height / 2

    dropped = cx >= rect.left && cx &lt;= rect.right && cy >= rect.top && cy &lt;= rect.bottom
  }

  if (dragRect && utils.is.number(dropOverlap)) {
    const overlapArea  = (Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) *
                          Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)))

    const overlapRatio = overlapArea / (dragRect.width * dragRect.height)

    dropped = overlapRatio >= dropOverlap
  }

  if (interactable.options.drop.checker) {
    dropped = interactable.options.drop.checker(dragEvent, event, dropped, interactable, dropElement, draggable, draggableElement)
  }

  return dropped
}

const drop = {
  id: 'actions/drop',
  install,
  getActiveDrops,
  getDrop,
  getDropEvents,
  fireDropEvents,
  defaults: {
    enabled: false,
    accept : null,
    overlap: 'pointer',
  } as Interact.DropzoneOptions,
}

export default drop
</code></pre></article></section></div></div></div><script src="//www.google-analytics.com/analytics.js" async></script><script src="https://cdn.jsdelivr.net/npm/interactjs@next/dist/interact.min.js"></script><div style="display: none"><div class="ad-wrapper" id="ad-wrapper"><script src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=interactjsio" async id="_carbonads_js"></script></div></div><script>window.addEventListener('hashchange', function () {
    if (location.hash === '#top') {
        if ("replaceState" in history) {
              history.replaceState("", document.title, location.pathname + location.search);
        }
        else {
          location.hash = '';
        }
    }
});

if (!/yes|1/.test(navigator.doNotTrack) || /MSIE|Trident/i.test(navigator.userAgent)) {
    (function(p,r,i,v,a,c,y){p['GoogleAnalyticsObject']=a;p[a]=p[a]||function(){
    (p[a].q=p[a].q||[]).push(arguments)},p[a].l=1*new Date();c=r.createElement(i),
    y=r.getElementsByTagName(i)[0];c.async=1;c.src=v;y.parentNode.insertBefore(c,y)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '', '');
    ga('send', 'pageview');
}</script><script src="/js/chunk-vendors.c6aabe48.js"></script><script src="/js/app.6102e1da.js"></script></body></html>